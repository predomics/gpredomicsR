# Generated by extendr: Do not edit by hand

# nolint start

#
# This file was created with the following call:
#   .Call("wrap__make_gpredomicsR_wrappers", use_symbols = TRUE, package_name = "gpredomicsR")

#' @usage NULL
#' @useDynLib gpredomicsR, .registration = TRUE
NULL

#' @title Run genetic algorithm
#' @name fit
#' @description Run the Gpredomics genetic algorithm to produce an Experiment from parameters
#' @details
#' This is the main entry point for running Gpredomics algorithms (GA, BEAM, MCMC).
#' The function loads data specified in the param object, runs the algorithm, and
#' returns a complete Experiment object with results. If param$voting$vote is TRUE,
#' a Jury ensemble is automatically computed.
#' 
#' @param param Param object containing experiment configuration (data paths, algorithm, CV settings)
#' @param running_flag RunningFlag object to control and monitor execution
#' @return Experiment object containing populations, final results, and optional Jury
#' @export
fit <- function(param, running_flag) .Call(wrap__fit, param, running_flag)

#' @title Run genetic algorithm with Data object
#' @name fit_on
#' @description Run the Gpredomics algorithm using a pre-loaded Data object
#' @details
#' This function runs Gpredomics algorithms (GA, BEAM, MCMC) on data already loaded in R.
#' Unlike fit(), this function uses an existing Data object instead of loading from file paths.
#' If param$voting$vote is TRUE, a Jury ensemble is automatically computed.
#' 
#' @param data Data object containing the training data (features and labels)
#' @param param Param object containing experiment configuration (algorithm, CV settings, etc.)
#' @param running_flag RunningFlag object to control and monitor execution
#' @return Experiment object containing populations, final results, and optional Jury
#' @export
fit_on <- function(data, param, running_flag) .Call(wrap__fit_on, data, param, running_flag)

#' Create a Gpredomics Data object from an R DataFrame `df` (X) and a named label vector `y`.
#'
#' Orientation and alignment:
#' - If `features_in_columns = true`: rows are samples, columns are features; `names(y)` must match `rownames(df)`.
#' - If `features_in_columns = false`: columns are samples, rows are features; `names(y)` must match `colnames(df)`.
#' - Samples are strictly aligned by exact string matching; any mismatch of names triggers an error.
#' - Internally, X is stored as a sparse map with keys `(sample_idx, feature_idx)`.
#'
#' Label handling (`y`):
#' - Accepts integer, character, or 2-level factor.
#' - If `y` has exactly two classes:
#'   - Character or factor: classes are extracted from the actual labels/levels and stored in `Data.classes`.
#'   - Integer:
#'     - If values are {0,1}, they are kept as-is (classes = ["0","1"]).
#'     - If two distinct integers {a,b} are detected, a warning is emitted and a→0, b→1 mapping is applied (classes = [str(a), str(b)]).
#' - If more than two non-missing classes are present, associated samples are classified as unknown.
#' - The binary vector `y` is reordered to match the chosen sample order derived from `df`.
#'
#' Requirements:
#' - `df` must be an R data.frame-like object where feature values are numeric/integer/logical.
#' - All sample names must be provided via `rownames(df)` (if `features_in_columns`) or `colnames(df)` (otherwise).
#' - `y` must be named with the exact same sample identifiers used on the chosen axis of `df`.
#'
#' Behavior on missing or invalid inputs:
#' - Missing `names(y)`: a warning is emitted; a fallback alignment to the chosen sample order is attempted, but exact names are recommended.
#' - Non-numeric feature columns (character): error advising to encode to numeric first.
#' - Column/row length mismatches: error with the offending index and dimensions.
#' - Any sample without a corresponding label in `y`: error with the sample name.
#' Errors:
#' - Detailed, user-facing messages are emitted via R console and returned as `Err(Error::Other(...))`.
#'
#' Notes:
#' - Name normalization is not performed; ensure consistent punctuation (e.g., "-" vs ".") on both `df` and `y`.
#' - For factors, R’s 1-based codes are mapped to their `levels` to retrieve human-readable class names.
#' 
#' @param df R data.frame-like object containing feature values.
#' @param y_vec R vector containing binary labels, named with sample identifiers.
#' @param features_in_columns Boolean indicating if features are in columns (`true`) or rows (`false`).
#' @param prior_weight Named numeric vector: feature name -> prior weight (optional)
#' @param feature_penalty Named numeric vector: feature name -> penalty (optional)
#' @param feature_tags R data.frame with feature annotations (optional)
#' @param sample_tags R data.frame with sample metadata (optional)
#' @return Gpredomics Data object with aligned and processed X and y.
#' @export
as_gpredomics_data <- function(df, y_vec, features_in_columns, prior_weight, feature_penalty, feature_tags, sample_tags) .Call(wrap__as_gpredomics_data, df, y_vec, features_in_columns, prior_weight, feature_penalty, feature_tags, sample_tags)

#' @title RunningFlag
#' @name RunningFlag
#' @description A struct to manage the running flag for controlling algorithm execution.
#' 
#' @details
#' The RunningFlag object allows you to control the execution of long-running algorithms.
#' It can be used to stop algorithms gracefully from another thread or after user interruption.
#' 
#' @section Methods:
#' \describe{
#'   \item{\code{new()}}{Create a new RunningFlag (initially set to TRUE).}
#'   \item{\code{stop()}}{Set the running flag to FALSE to signal algorithm termination.}
#'   \item{\code{is_running()}}{Check the current value of the running flag (TRUE or FALSE).}
#'   \item{\code{reset()}}{Reset the running flag to TRUE.}
#' }
#' 
#' @export
RunningFlag <- new.env(parent = emptyenv())

RunningFlag$new <- function() .Call(wrap__RunningFlag__new)

RunningFlag$stop <- function() invisible(.Call(wrap__RunningFlag__stop, self))

RunningFlag$is_running <- function() .Call(wrap__RunningFlag__is_running, self)

RunningFlag$reset <- function() invisible(.Call(wrap__RunningFlag__reset, self))

#' @rdname RunningFlag
#' @usage NULL
#' @export
`$.RunningFlag` <- function (self, name) { func <- RunningFlag[[name]]; environment(func) <- environment(); func }

#' @export
`[[.RunningFlag` <- `$.RunningFlag`

#' @title Experiment
#' @name Experiment
#' @description Complete experiment container for Gpredomics runs
#' @details 
#' Experiment encapsulates an entire Gpredomics run including:
#' - Training and optional test data
#' - Algorithm parameters
#' - Evolution history (populations across generations)
#' - Cross-validation fold information (if applicable)
#' - Final best population and optional Jury
#' - Execution metadata (timestamp, version, execution time)
#' 
#' @section Methods:
#' \describe{
#'   \item{\code{individual(generation, order)}}{Retrieves a full description of an individual from a specified generation and order. Parameters: generation (i32 generation index), order (i32 order within generation). Returns Individual object.}
#'   \item{\code{test_data()}}{Retrieves the test data associated with the experiment. Returns Data object representing the test data.}
#'   \item{\code{train_data()}}{Retrieves the training data associated with the experiment. Returns Data object representing the training data.}
#'   \item{\code{get_data_robj(train)}}{Retrieves the data associated with the experiment as an R object. Parameter: train (logical; if TRUE, returns training data, otherwise test data). Returns R object representing the data.}
#'   \item{\code{get_data(train)}}{Retrieves the data associated with the experiment as a Data object. Parameter: train (logical; if TRUE, returns training data, otherwise test data). Returns Data object.}
#'   \item{\code{get_generation(generation)}}{Retrieves descriptions of all individuals from a specified generation. Parameter: generation (i32 generation index). Returns R list object encapsulating features and metrics of all individuals in the generation.}
#'   \item{\code{get_fold_data(fold, train)}}{Get fold data for cross-validation. Parameters: fold (fold index 0-based), train (logical: if TRUE returns training data, if FALSE returns validation data). Returns Data object for the specified fold.}
#'   \item{\code{get_fold_generation(fold, generation, train)}}{Get population from a specific CV fold and generation. Parameters: fold (fold index 0-based), generation (generation index 0-based), train (logical: if TRUE uses training data, if FALSE uses validation data, default TRUE). Returns Population object.}
#'   \item{\code{get_n_folds()}}{Get the number of cross-validation folds in the experiment. Returns number of CV folds as integer.}
#'   \item{\code{get_best_population()}}{Get the final/best population from the experiment. Returns Population object containing the best individuals.}
#'   \item{\code{compute_cv_importance(n_perm, aggregation, scaled, seed, compact)}}{Compute cross-validated feature importance (MDA-like) aggregated across CV folds. Parameters: n_perm (number of permutations, default 1000), aggregation ("mean" or "median", default "mean"), scaled (whether to scale, default TRUE), seed (random seed, default 4815162342), compact (return vector if TRUE or data.frame if FALSE, default FALSE). Returns either data.frame or named vector.}
#'   \item{\code{compute_cv_importance_matrix(n_perm, used_only, seed, aggregation, scaled)}}{Compute per-fold CV population-level importance matrix. Parameters: n_perm (number of permutations, default 1000), used_only (restrict to FBM features, default TRUE), seed (base seed for RNG, default 4815162342), aggregation (population aggregation method: "mean" or "median", default "mean"), scaled (scale importances, default TRUE). Returns numeric matrix: n_features x n_folds.}
#'   \item{\code{generation_number()}}{Get the number of generations in the population. Returns number of generations.}
#'   \item{\code{population_size(generation)}}{Get the size (number of individuals) of a certain generation in a Population. Parameter: generation (i32 generation index). Returns integer size.}
#'   \item{\code{load_data(x_path, y_path)}}{Load an external dataset to evaluate the model. Parameters: x_path (path to X data file), y_path (path to y data file). Returns Data object containing the loaded data.}
#'   \item{\code{get_param()}}{Get the param object associated with the experiment. Returns Param object containing the experiment parameters.}
#'   \item{\code{get_jury()}}{Get the jury object associated with the experiment. Returns Jury object containing the jury details.}
#'   \item{\code{load(path)}}{Load a serialized experiment. Parameter: path (path to the experiment file). Returns loaded Experiment object.}
#'   \item{\code{save(path)}}{Save an experiment. Parameter: path (path to save the experiment).}
#'   \item{\code{get_population(generation)}}{Extract population from experiment, optionally specifying generation number. Parameter: generation (optional generation number, 0-based; if None, returns final population). Returns Population object for the specified generation or final population.}
#'   \item{\code{address()}}{Get memory address of this Experiment object. Returns string representing the memory address.}
#'   \item{\code{print()}}{Get print of this Experiment. Returns string representing the Experiment summary.}
#'   \item{\code{get_history(data, scope)}}{Get training history with specified scope. Parameters: data (Data object to evaluate on), scope ("best", "fbm", "top5", or "all", default "best"). Returns data.frame with metrics per generation (and per fold if CV).}
#' }
#' @export
Experiment <- new.env(parent = emptyenv())

Experiment$individual <- function(generation, order) .Call(wrap__Experiment__individual, self, generation, order)

Experiment$test_data <- function() .Call(wrap__Experiment__test_data, self)

Experiment$train_data <- function() .Call(wrap__Experiment__train_data, self)

Experiment$get_data_robj <- function(train) .Call(wrap__Experiment__get_data_robj, self, train)

Experiment$get_data <- function(train) .Call(wrap__Experiment__get_data, self, train)

Experiment$get_generation <- function(generation) .Call(wrap__Experiment__get_generation, self, generation)

Experiment$get_fold_data <- function(fold, train) .Call(wrap__Experiment__get_fold_data, self, fold, train)

Experiment$get_fold_generation <- function(fold, generation, train) .Call(wrap__Experiment__get_fold_generation, self, fold, generation, train)

Experiment$get_n_folds <- function() .Call(wrap__Experiment__get_n_folds, self)

Experiment$get_best_population <- function() .Call(wrap__Experiment__get_best_population, self)

Experiment$compute_cv_importance <- function(n_perm, aggregation, scaled, seed, compact) .Call(wrap__Experiment__compute_cv_importance, self, n_perm, aggregation, scaled, seed, compact)

Experiment$compute_cv_importance_matrix <- function(n_perm, used_only, seed, aggregation, scaled) .Call(wrap__Experiment__compute_cv_importance_matrix, self, n_perm, used_only, seed, aggregation, scaled)

Experiment$generation_number <- function() .Call(wrap__Experiment__generation_number, self)

Experiment$population_size <- function(generation) .Call(wrap__Experiment__population_size, self, generation)

Experiment$load_data <- function(x_path, y_path, features_in_columns) .Call(wrap__Experiment__load_data, self, x_path, y_path, features_in_columns)

Experiment$get_param <- function() .Call(wrap__Experiment__get_param, self)

Experiment$get_jury <- function() .Call(wrap__Experiment__get_jury, self)

Experiment$load <- function(path) .Call(wrap__Experiment__load, path)

Experiment$save <- function(path) invisible(.Call(wrap__Experiment__save, self, path))

Experiment$get_population <- function(generation) .Call(wrap__Experiment__get_population, self, generation)

Experiment$address <- function() .Call(wrap__Experiment__address, self)

Experiment$print <- function() .Call(wrap__Experiment__print, self)

Experiment$get_history <- function(data, scope) .Call(wrap__Experiment__get_history, self, data, scope)

#' @rdname Experiment
#' @usage NULL
#' @export
`$.Experiment` <- function (self, name) { func <- Experiment[[name]]; environment(func) <- environment(); func }

#' @export
`[[.Experiment` <- `$.Experiment`

#' @title Param
#' @name Param
#' @description Gpredomics parameter object that stores all algorithm settings.
#' 
#' @details
#' The Param object contains all configuration settings for running gpredomics algorithms
#' including genetic algorithm parameters, data parameters, cross-validation settings, etc.
#' 
#' @section Methods:
#' \describe{
#'   \item{\code{new()}}{Create a new empty Param object.}
#'   \item{\code{load(file_path)}}{Load a param.yaml file to create a new Param. 
#'     \itemize{
#'       \item \code{file_path}: Path to param.yaml file
#'     }
#'   }
#'   \item{\code{get()}}{Returns an R list representing the current state of Param with all settings.}
#'   \item{\code{set(variable, value)}}{Set a numeric parameter by name.
#'     \itemize{
#'       \item \code{variable}: Name of the parameter to set
#'       \item \code{value}: New numeric value for the parameter
#'     }
#'   }
#'   \item{\code{set_string(variable, string)}}{Set a string parameter by name.
#'     \itemize{
#'       \item \code{variable}: Name of the parameter to set
#'       \item \code{string}: New string value for the parameter
#'     }
#'   }
#'   \item{\code{set_bool(variable, value)}}{Set a boolean parameter by name.
#'     \itemize{
#'       \item \code{variable}: Name of the parameter to set
#'       \item \code{value}: New boolean value for the parameter
#'     }
#'   }
#'   \item{\code{address()}}{Get memory address of this Param object as a string.}
#' }
#' 
#' @export
Param <- new.env(parent = emptyenv())

Param$new <- function() .Call(wrap__Param__new)

Param$load <- function(file_path) .Call(wrap__Param__load, file_path)

Param$get <- function() .Call(wrap__Param__get, self)

Param$set <- function(variable, value) invisible(.Call(wrap__Param__set, self, variable, value))

Param$address <- function() .Call(wrap__Param__address, self)

Param$set_string <- function(variable, string) invisible(.Call(wrap__Param__set_string, self, variable, string))

Param$set_bool <- function(variable, value) invisible(.Call(wrap__Param__set_bool, self, variable, value))

#' @rdname Param
#' @usage NULL
#' @export
`$.Param` <- function (self, name) { func <- Param[[name]]; environment(func) <- environment(); func }

#' @export
`[[.Param` <- `$.Param`

#' @title GLogger
#' @name GLogger
#' @description An object to handle Logger
#' @details 
#' GLogger provides a configurable logging interface for the gpredomics package.
#' It supports different logging levels (info, debug, error, etc.) and can output
#' to screen or files with customizable formatting.
#' 
#' @section Methods:
#' \describe{
#'   \item{\code{new()}}{Create a new screen logger with default 'info' level. Returns GLogger object.}
#'   \item{\code{level(level)}}{Create a new screen logger with specified logging level. Parameter: level (logging level string, e.g., "info", "debug", "error"). Returns GLogger object.}
#'   \item{\code{get(param)}}{Create a new logger from a Param object containing logging configuration. Parameter: param (Param object containing logging configuration). Returns GLogger object.}
#'   \item{\code{set_level(level)}}{Change logging level. Parameter: level (new logging level string, e.g., "info", "debug", "error").}
#' }
#' @export
GLogger <- new.env(parent = emptyenv())

GLogger$new <- function() .Call(wrap__GLogger__new)

GLogger$level <- function(level) .Call(wrap__GLogger__level, level)

GLogger$get <- function(param) .Call(wrap__GLogger__get, param)

GLogger$set_level <- function(level) invisible(.Call(wrap__GLogger__set_level, self, level))

#' @rdname GLogger
#' @usage NULL
#' @export
`$.GLogger` <- function (self, name) { func <- GLogger[[name]]; environment(func) <- environment(); func }

#' @export
`[[.GLogger` <- `$.GLogger`

#' @title Individual
#' @name Individual
#' @description A single predictive model from the Gpredomics algorithm
#' @details 
#' Individual represents a single model (individual) in the population.
#' It contains:
#' - Feature set with coefficients (sparse representation)
#' - Performance metrics (AUC, accuracy, sensitivity, specificity, fit value)
#' - Optional threshold confidence interval and rejection rate
#' - Optional beta coefficients for certain model types
#' - Optional additional metrics (MCC, NPV, PPV, F1-score, G-mean)
#' - Genealogical information (parents, generation/epoch)
#' 
#' @section Methods:
#' \describe{
#'   \item{\code{get()}}{Get complete individual description including all fields and metrics}
#'   \item{\code{get_metrics()}}{Get base metrics (AUC, fit, accuracy, sensitivity, specificity, threshold, rejection_rate)}
#'   \item{\code{compute_metrics(data)}}{Compute all metrics including additional ones (MCC, NPV, PPV, F1-score, G-mean) on new data}
#'   \item{\code{predict(data)}}{Predict classes and scores for samples in the provided Data object}
#'   \item{\code{fit(data, param)}}{Refit individual on new data with complete metric computation including penalties}
#'   \item{\code{refit()}}{Refit individual on its associated data using complete Gpredomics logic}
#'   \item{\code{evaluate()}}{Compute prediction scores on associated data}
#'   \item{\code{to_string()}}{Get debug string representation}
#'   \item{\code{address()}}{Get memory address as hexadecimal string}
#'   \item{\code{print()}}{Print formatted individual summary to console}
#'   \item{\code{set_threshold(threshold)}}{Set prediction threshold for binary classification}
#'   \item{\code{compute_importance(data, n_perm, seed, used_only)}}{Compute OOB permutation feature importance}
#'   \item{\code{prune_by_threshold(threshold, n_perm, seed, min_k)}}{Remove low-importance features using absolute threshold}
#'   \item{\code{prune_by_quantile(quantile, eps, n_perm, seed, min_k)}}{Remove low-importance features using quantile threshold}
#'   \item{\code{get_genealogy(experiment, max_depth)}}{Retrieve ancestry tree across generations for visualization}
#'   \item{\code{explain_sample(data, sample_index)}}{Explain individual prediction for one sample with feature contributions. Parameters: data (Data object), sample_index (1-based R index). Returns data.frame with Feature, Value, Coefficient, Contribution, CumScore.}
#' }
#' @export
Individual <- new.env(parent = emptyenv())

Individual$get <- function() .Call(wrap__Individual__get, self)

Individual$get_metrics <- function() .Call(wrap__Individual__get_metrics, self)

Individual$compute_metrics <- function(data) .Call(wrap__Individual__compute_metrics, self, data)

Individual$fit <- function(data, param) .Call(wrap__Individual__fit, self, data, param)

Individual$refit <- function() .Call(wrap__Individual__refit, self)

Individual$evaluate <- function() .Call(wrap__Individual__evaluate, self)

Individual$predict <- function(data) .Call(wrap__Individual__predict, self, data)

Individual$to_string <- function() .Call(wrap__Individual__to_string, self)

Individual$address <- function() .Call(wrap__Individual__address, self)

Individual$print <- function() invisible(.Call(wrap__Individual__print, self))

Individual$set_threshold <- function(threshold) .Call(wrap__Individual__set_threshold, self, threshold)

Individual$compute_importance <- function(data, n_perm, seed, used_only) .Call(wrap__Individual__compute_importance, self, data, n_perm, seed, used_only)

Individual$prune_by_threshold <- function(threshold, n_perm, seed, min_k) .Call(wrap__Individual__prune_by_threshold, self, threshold, n_perm, seed, min_k)

Individual$prune_by_quantile <- function(quantile, eps, n_perm, seed, min_k) .Call(wrap__Individual__prune_by_quantile, self, quantile, eps, n_perm, seed, min_k)

Individual$get_genealogy <- function(experiment, max_depth) .Call(wrap__Individual__get_genealogy, self, experiment, max_depth)

Individual$explain_sample <- function(data, sample_index) .Call(wrap__Individual__explain_sample, self, data, sample_index)

#' @rdname Individual
#' @usage NULL
#' @export
`$.Individual` <- function (self, name) { func <- Individual[[name]]; environment(func) <- environment(); func }

#' @export
`[[.Individual` <- `$.Individual`

#' @title Data
#' @name Data
#' @description Gpredomics Data object containing feature matrix and labels.
#' 
#' @details
#' The Data object stores the feature matrix (X), labels (y), sample names, feature names,
#' and other metadata needed for machine learning algorithms.
#' 
#' @section Methods:
#' \describe{
#'   \item{\code{new()}}{Create a new empty Data object.}
#'   \item{\code{get()}}{Returns an R list with all Data fields (X, y, features, samples, etc.).}
#'   \item{\code{address()}}{Get memory address of this Data object as a string.}
#'   \item{\code{print()}}{Get a formatted string summary of the Data dimensions and content.}
#'   \item{\code{train_test_split(test_ratio, stratify_by, seed)}}{Stratified train/test split. Parameters: test_ratio (fraction for test set, 0-1), stratify_by (optional column name in sample annotations for double stratification), seed (optional random seed). Returns a list with train and test Data objects.}
#' }
#' 
#' @export
Data <- new.env(parent = emptyenv())

Data$new <- function() .Call(wrap__Data__new)

Data$get <- function() .Call(wrap__Data__get, self)

Data$address <- function() .Call(wrap__Data__address, self)

Data$print <- function() .Call(wrap__Data__print, self)

Data$train_test_split <- function(test_ratio, stratify_by, seed) .Call(wrap__Data__train_test_split, self, test_ratio, stratify_by, seed)

#' @rdname Data
#' @usage NULL
#' @export
`$.Data` <- function (self, name) { func <- Data[[name]]; environment(func) <- environment(); func }

#' @export
`[[.Data` <- `$.Data`

#' @title Population
#' @name Population
#' @description gpredomics Population object
#' @details 
#' Population represents a collection of Individuals.
#' It provides methods to filter, analyze, and manipulate sets of individuals, as well as compute
#' aggregate predictions and feature importances across the population.
#' 
#' @section Methods:
#' \describe{
#'   \item{\code{get()}}{Get the population associated with the experiment. Returns R object representing the Population.}
#'   \item{\code{display_feature_prevalence(data, nb_features)}}{Display the prevalence of features in the population. Parameters: data (Data object), nb_features (number of top features to display).}
#'   \item{\code{predict_score_matrix(data)}}{Predict all individuals of the population on data and return a dataframe (Rows = samples, Columns = individuals/experts). Parameter: data (Data object to predict on). Returns dataframe with predicted scores.}
#'   \item{\code{predict_class_matrix(data)}}{Predict classes for all individuals of the population on data and return a dataframe (Rows = samples, Columns = individuals/experts, Values = predicted classes 0 or 1). Parameter: data (Data object to predict on). Returns dataframe with predicted classes.}
#'   \item{\code{filter_by_auc(min_auc)}}{Filter population by AUC threshold. Parameter: min_auc (minimum AUC threshold). Returns filtered Population object.}
#'   \item{\code{filter_by_fit(min_fit)}}{Filter population by fitness threshold. Parameter: min_fit (minimum fit threshold). Returns filtered Population object.}
#'   \item{\code{filter_by_diversity(min_diversity_pct, by_niche)}}{Filter population by diversity using Jaccard dissimilarity. Parameters: min_diversity_pct (minimum diversity percentage 0-100), by_niche (whether to compute diversity within niches). Returns filtered Population object.}
#'   \item{\code{filter_by_sensitivity(min_sensitivity)}}{Filter population by sensitivity threshold. Parameter: min_sensitivity (minimum sensitivity threshold). Returns filtered Population object.}
#'   \item{\code{filter_by_specificity(min_specificity)}}{Filter population by specificity threshold. Parameter: min_specificity (minimum specificity threshold). Returns filtered Population object.}
#'   \item{\code{filter_by_mask(mask)}}{Filter population using a logical vector (1/0). Parameter: mask (integer vector 1/0 indicating which individuals to keep). Returns filtered Population object.}
#'   \item{\code{filter_by_k(min_k, max_k)}}{Filter population by number of features (k). Parameters: min_k (minimum number of features), max_k (maximum number of features). Returns filtered Population object.}
#'   \item{\code{get_fbm(alpha)}}{Get Family of Best Models (FBM) using confidence interval selection. This method selects models with performance statistically equivalent to the best model. Parameters: alpha (confidence level, default 0.05 for 95% confidence). If FBM selection fails, alpha% to keep). Returns Population object containing the FBM.}
#'   \item{\code{get_first_pct(pct)}}{Get first percentage of individuals sorted by fitness. Parameter: pct (percentage 0-100). Returns Population object containing the selected individuals.
#'   \item{\code{fit(data, param)}}{Compute fitness metrics for all individuals on new data or parameters and sort it. Parameters: data (new Data object to fit on), param (Param object containing fit function and penalties).}
#'   \item{\code{prune_by_threshold(threshold, n_perm, seed, min_k)}}{Prune all individuals by importance threshold. Parameters: threshold (importance threshold), n_perm (number of permutations, default 100), seed (base seed for RNG, default 4815162342), min_k (minimum features to keep, default 1). Returns new Population with pruned individuals.}
#'   \item{\code{prune_by_quantile(quantile, eps, n_perm, seed, min_k)}}{Prune all individuals by importance quantile. Parameters: quantile (quantile value 0-1), eps (epsilon value, default 0.0), n_perm (number of permutations, default 100), seed (base seed for RNG, default 4815162342), min_k (minimum features to keep, default 1). Returns new Population with pruned individuals.}
#'   \item{\code{address()}}{Get memory address of this Population object. Returns string representing the memory address.}
#'   \item{\code{get_individual(index)}}{Get an Individual of a population by index. Parameter: index (index of the individual to retrieve). Returns Individual object at the specified index.}
#'   \item{\code{print_as_gpredomics()}}{Print the Population in gpredomics style to R console.}
#'   \item{\code{print()}}{Get comprehensive print information about the population. Returns string representing the Population summary.}
#'   \item{\code{from_individuals(individuals)}}{Create a Population from a vector or list of R Individual objects. Parameter: individuals (R vector or list of Individual objects, must have at least one). Returns Population object created from the individuals.}
#'   \item{\code{extend(other)}}{Extend this population with another population. Parameter: other (another Population object to add).}
#'   \item{\code{add_individuals(individuals)}}{Add individuals from a vector or list to this population. Parameter: individuals (R vector or list of Individual objects).}
#'   \item{\code{compute_importance(data, n_perm, aggregation, scaled, seed, compact)}}{Compute full Population-level MDA importances for this Population on given Data. Parameters: data (Data object to compute importances on), n_perm (number of permutations, default 1000), aggregation (aggregation method: "mean" (default) or "median"), scaled (whether to scale importances, default TRUE), seed (random seed for reproducibility, default 4815162342), compact (whether to return a compact vector (TRUE) or full data.frame (FALSE, default)). Returns DataFrame with columns: feature, importance, dispersion, prevalence.}
#'   \item{\code{compute_importance_matrix(data, n_perm, used_only, seed)}}{Compute full Population-level MDA importance matrix for this Population on given Data. Parameters: data (Data object to compute importances on), n_perm (number of permutations, default 1000), used_only (whether to compute importances only for features used in the population, default TRUE), seed (random seed for reproducibility, default 4815162342). Returns Matrix (data.frame) with rows = features, columns = individuals.}
#' }
#' @export
Population <- new.env(parent = emptyenv())

Population$get <- function() .Call(wrap__Population__get, self)

Population$display_feature_prevalence <- function(data, nb_features) invisible(.Call(wrap__Population__display_feature_prevalence, self, data, nb_features))

Population$predict_score_matrix <- function(data) .Call(wrap__Population__predict_score_matrix, self, data)

Population$predict_class_matrix <- function(data) .Call(wrap__Population__predict_class_matrix, self, data)

Population$filter_by_auc <- function(min_auc) .Call(wrap__Population__filter_by_auc, self, min_auc)

Population$filter_by_fit <- function(min_fit) .Call(wrap__Population__filter_by_fit, self, min_fit)

Population$filter_by_diversity <- function(min_diversity_pct, by_niche) .Call(wrap__Population__filter_by_diversity, self, min_diversity_pct, by_niche)

Population$filter_by_sensitivity <- function(min_sensitivity) .Call(wrap__Population__filter_by_sensitivity, self, min_sensitivity)

Population$filter_by_specificity <- function(min_specificity) .Call(wrap__Population__filter_by_specificity, self, min_specificity)

Population$filter_by_mask <- function(mask) .Call(wrap__Population__filter_by_mask, self, mask)

Population$filter_by_k <- function(min_k, max_k) .Call(wrap__Population__filter_by_k, self, min_k, max_k)

Population$get_fbm <- function(alpha) .Call(wrap__Population__get_fbm, self, alpha)

Population$get_first_pct <- function(pct) .Call(wrap__Population__get_first_pct, self, pct)

Population$fit <- function(data, param) .Call(wrap__Population__fit, self, data, param)

Population$prune_by_threshold <- function(threshold, n_perm, seed, min_k) .Call(wrap__Population__prune_by_threshold, self, threshold, n_perm, seed, min_k)

Population$prune_by_quantile <- function(quantile, eps, n_perm, seed, min_k) .Call(wrap__Population__prune_by_quantile, self, quantile, eps, n_perm, seed, min_k)

Population$address <- function() .Call(wrap__Population__address, self)

Population$get_individual <- function(index) .Call(wrap__Population__get_individual, self, index)

Population$print_as_gpredomics <- function() invisible(.Call(wrap__Population__print_as_gpredomics, self))

Population$print <- function() .Call(wrap__Population__print, self)

Population$from_individuals <- function(individuals) .Call(wrap__Population__from_individuals, individuals)

Population$extend <- function(other) invisible(.Call(wrap__Population__extend, self, other))

Population$add_individuals <- function(individuals) invisible(.Call(wrap__Population__add_individuals, self, individuals))

Population$compute_importance <- function(data, n_perm, aggregation, scaled, seed, compact) .Call(wrap__Population__compute_importance, self, data, n_perm, aggregation, scaled, seed, compact)

Population$compute_importance_matrix <- function(data, n_perm, used_only, seed) .Call(wrap__Population__compute_importance_matrix, self, data, n_perm, used_only, seed)

#' @rdname Population
#' @usage NULL
#' @export
`$.Population` <- function (self, name) { func <- Population[[name]]; environment(func) <- environment(); func }

#' @export
`[[.Population` <- `$.Population`

#' @title Jury
#' @name Jury
#' @description gpredomics Jury object
#' @details 
#' Jury represents an ensemble of expert models (a calibrated population) that make predictions
#' through voting and weighting schemes. It implements various voting methods (majority, consensus)
#' to aggregate predictions from multiple experts.
#' 
#' @section Methods:
#' \describe{
#'   \item{\code{new_from_param(population, param)}}{Constructs a Jury object from a population and parameters. Parameters: population (Population of experts to form the Jury), param (Parameters for the Jury). Returns Jury object.}
#'   \item{\code{from_population(population, threshold, window)}}{Create a Jury directly from a Population without applying any filters. Parameters: population (Population to use as experts), threshold (Voting threshold, default 0.5), window (Threshold window percentage, default 5.0). Returns Jury object.}
#'   \item{\code{get()}}{Returns an R object containing all Jury fields for R interface. Returns list with Jury fields.}
#'   \item{\code{get_metrics()}}{Get the base metrics already computed and stored in this Jury (AUC, accuracy, sensitivity, specificity, rejection_rate). No data required, no computation. Returns a list with base metrics only.}
#'   \item{\code{compute_metrics(data)}}{Compute all metrics (base + additional: MCC, NPV, PPV, F1-score, G-mean) on the provided Data object. Returns a list with all computed metrics.}
#'   \item{\code{predict(data)}}{Predict classes and scores on the provided Data object. Returns a list with two elements: class (predicted classes) and score (predicted scores).}
#'   \item{\code{fit(data)}}{Fit/calibrate the Jury on new data by recomputing weights, thresholds, and all metrics. Parameter: data (Data object used for calibration).}
#'   \item{\code{get_population()}}{Extract the population from the jury (experts). Returns Population object containing the experts.}
#'   \item{\code{print_self_report()}}{Display the Jury report with self-evaluation metrics to console.}
#'   \item{\code{print_report(test_data)}}{Display the Jury report with both training and test data evaluation. Parameter: test_data (Data object for test evaluation).}
#'   \item{\code{address()}}{Get memory address of this Jury object. Returns string representing the memory address.}
#'   \item{\code{print()}}{Get summary of this Jury. Returns string representing the Jury summary.}
#' }
#' @export
Jury <- new.env(parent = emptyenv())

Jury$new_from_param <- function(population, param) .Call(wrap__Jury__new_from_param, population, param)

Jury$from_population <- function(population, threshold, window) .Call(wrap__Jury__from_population, population, threshold, window)

Jury$get <- function() .Call(wrap__Jury__get, self)

Jury$get_metrics <- function() .Call(wrap__Jury__get_metrics, self)

Jury$compute_metrics <- function(data) .Call(wrap__Jury__compute_metrics, self, data)

Jury$predict <- function(data) .Call(wrap__Jury__predict, self, data)

Jury$fit <- function(data) invisible(.Call(wrap__Jury__fit, self, data))

Jury$print_self_report <- function() invisible(.Call(wrap__Jury__print_self_report, self))

Jury$print_report <- function(test_data) invisible(.Call(wrap__Jury__print_report, self, test_data))

Jury$get_population <- function() .Call(wrap__Jury__get_population, self)

Jury$address <- function() .Call(wrap__Jury__address, self)

Jury$print <- function() .Call(wrap__Jury__print, self)

#' @rdname Jury
#' @usage NULL
#' @export
`$.Jury` <- function (self, name) { func <- Jury[[name]]; environment(func) <- environment(); func }

#' @export
`[[.Jury` <- `$.Jury`


# nolint end
